diff -crN ./esound/Makefile.am /users5/vivierl/sandboxes/gnome_202/src/./esound/Makefile.am
*** ./esound/Makefile.am	2002-08-26 18:41:03.000000000 +0200
--- /users5/vivierl/sandboxes/gnome_202/src/./esound/Makefile.am	2003-02-13 14:14:03.000000000 +0100
***************
*** 49,55 ****
  	audio_none.c	\
  	audio_oss.c	\
  	audio_mklinux.c	\
! 	audio_solaris.c	
  
  libesddsp_la_LDFLAGS = -version-info $(ESD_VERSION_INFO)
  libesddsp_la_LIBADD = $(DL_LIB) -lm
--- 49,56 ----
  	audio_none.c	\
  	audio_oss.c	\
  	audio_mklinux.c	\
! 	audio_solaris.c	\
! 	esdlibnas.c
  
  libesddsp_la_LDFLAGS = -version-info $(ESD_VERSION_INFO)
  libesddsp_la_LIBADD = $(DL_LIB) -lm
diff -crN ./esound/acconfig.h /users5/vivierl/sandboxes/gnome_202/src/./esound/acconfig.h
*** ./esound/acconfig.h	2002-08-26 18:41:22.000000000 +0200
--- /users5/vivierl/sandboxes/gnome_202/src/./esound/acconfig.h	2003-02-13 14:14:03.000000000 +0100
***************
*** 8,13 ****
--- 8,14 ----
  #undef DRIVER_ALSA
  #undef DRIVER_NEWALSA
  #undef DRIVER_ALSA_09
+ #undef DRIVER_NAS
  #undef DRIVER_DART
  #undef DRIVER_NONE
  #undef HAVE_INET_ATON
diff -crN ./esound/configure.in /users5/vivierl/sandboxes/gnome_202/src/./esound/configure.in
*** ./esound/configure.in	2002-08-26 19:12:12.000000000 +0200
--- /users5/vivierl/sandboxes/gnome_202/src/./esound/configure.in	2003-02-13 14:14:03.000000000 +0100
***************
*** 48,53 ****
--- 48,54 ----
  AC_CHECK_FUNC(gethostbyname,,[AC_CHECK_LIB(nsl,gethostbyname)])
  AC_CHECK_FUNC(nanosleep,,[
    AC_CHECK_LIB(rt,nanosleep,,[AC_CHECK_LIB(posix4,nanosleep)])])
+ AC_CHECK_FUNCS(nsleep)
  AC_CHECK_FUNCS(usleep)
  AC_CHECK_FUNC(inet_aton,,[AC_CHECK_LIB(resolv,inet_aton)])
  AC_CHECK_FUNCS(strtok_r)
***************
*** 88,93 ****
--- 89,115 ----
  
  AC_CHECK_HEADERS(sys/filio.h sys/ioctl.h)
  
+ dnl Need NAS to send sound to X/Terminal
+ 
+ AC_ARG_ENABLE(nas,[  --enable-nas            use Network Audio System if available (AIX ONLY) [default=no]], , enable_nas=no)
+ 
+ case ${host_os} in
+    aix*)
+ 	if test "x$enable_nas" = "xyes"; then
+ 	   AC_PATH_XTRA
+ 	   SOUND_LIBS="$X_PRE_LIBS $X_LIBS -lXau $X_EXTRA_LIBS"
+ 	   AC_CHECK_LIB(audio, AuOpenServer, , AC_MSG_ERROR([Could not find libaudio for NAS support]), $SOUND_LIBS)
+ 	   AC_CHECK_HEADER(audio/audiolib.h, , AC_MSG_ERROR([Could not find header file for NAS support]))
+ 	   AC_DEFINE(DRIVER_NAS)
+ 	fi
+ 	;;
+     *)
+ 	if test "x$enable_nas" = "xyes"; then
+ 	    AC_MSG_ERROR([Network Audio System is not supported on your system])
+ 	fi
+ 	;;
+ esac
+ 
  dnl see if we want to enable insanely verbose debugging
  
  AC_ARG_ENABLE(debugging,[  --enable-debugging      enable verbose diagnostic info [default=no]], , enable_debugging=no )
diff -crN ./esound/esd.c /users5/vivierl/sandboxes/gnome_202/src/./esound/esd.c
*** ./esound/esd.c	2002-08-26 18:41:24.000000000 +0200
--- /users5/vivierl/sandboxes/gnome_202/src/./esound/esd.c	2003-02-13 14:14:03.000000000 +0100
***************
*** 8,14 ****
  #include <signal.h>
  #include <time.h>
  
! #ifndef HAVE_NANOSLEEP
  #include <sys/time.h>
  #include <sys/types.h>
  #include <unistd.h>
--- 8,14 ----
  #include <signal.h>
  #include <time.h>
  
! #if defined(HAVE_NSLEEP) || defined(HAVE_NANOSLEEP)
  #include <sys/time.h>
  #include <sys/types.h>
  #include <unistd.h>
***************
*** 900,905 ****
--- 900,914 ----
  	}
  
  	if ( esd_on_standby ) {
+ #ifdef HAVE_NSLEEP
+ 	    struct timestruc_t restrain;
+ 	    restrain.tv_sec = 0;
+ 	    /* funky math to make sure a long can hold it all, calulate in ms */
+ 	    restrain.tv_nsec = (long) esd_buf_size_samples * 1000L
+ 		/ (long) esd_audio_rate / 4L;   /* divide by two for stereo */
+ 	    restrain.tv_nsec *= 1000000L;       /* convert to nanoseconds */
+ 	    nsleep( &restrain, NULL );
+ #else
  #ifdef HAVE_NANOSLEEP
  	    struct timespec restrain;
  	    restrain.tv_sec = 0;
***************
*** 917,922 ****
--- 926,932 ----
  	    restrain.tv_usec *= 1000L; 		/* convert to microseconds */
  	    select( 0, 0, 0, 0, &restrain );
  #endif
+ #endif
  	}
      } /* while ( 1 ) */
  
diff -crN ./esound/esd.h /users5/vivierl/sandboxes/gnome_202/src/./esound/esd.h
*** ./esound/esd.h	2002-08-26 18:41:24.000000000 +0200
--- /users5/vivierl/sandboxes/gnome_202/src/./esound/esd.h	2003-02-13 14:14:03.000000000 +0100
***************
*** 189,194 ****
--- 189,195 ----
  /* double again ... etc.                                           */
  int esd_get_latency(int esd);
      
+ ssize_t esd_write(int fd, const void* buf, size_t nbytes);
  
  /*******************************************************************/
  /* esdmgr.c - functions to implement a "sound manager" for esd */
***************
*** 330,339 ****
  const char *esd_get_socket_dirname();
  const char *esd_get_socket_name();
  
- 
  #ifdef __cplusplus
  }
  #endif
  
- 
  #endif /* #ifndef ESD_H */
--- 331,338 ----
diff -crN ./esound/esdlib.c /users5/vivierl/sandboxes/gnome_202/src/./esound/esdlib.c
*** ./esound/esdlib.c	2002-07-15 11:28:26.000000000 +0200
--- /users5/vivierl/sandboxes/gnome_202/src/./esound/esdlib.c	2003-02-13 14:14:03.000000000 +0100
***************
*** 1,4 ****
- 
  #include "config.h"
  #include "esd.h"
  #include "genrand.h"
--- 1,3 ----
***************
*** 23,28 ****
--- 22,31 ----
  
  #include <sys/un.h>
  
+ #ifdef DRIVER_NAS
+ #include "esdlibnas.c"
+ #endif /* DRIVER_NAS */
+ 
  /*******************************************************************/
  /* prototypes */
  int esd_set_socket_buffers( int sock, int src_format, 
***************
*** 1421,1423 ****
--- 1424,1431 ----
  
      return close( esd );
  }
+ 
+ ssize_t esd_write (int __fd, const void *__buf, size_t __n)
+ {
+     return write(__fd, __buf, __n);
+ }
diff -crN ./esound/esdlibnas.c /users5/vivierl/sandboxes/gnome_202/src/./esound/esdlibnas.c
*** ./esound/esdlibnas.c	1970-01-01 01:00:00.000000000 +0100
--- /users5/vivierl/sandboxes/gnome_202/src/./esound/esdlibnas.c	2003-02-13 14:14:03.000000000 +0100
***************
*** 0 ****
--- 1,1396 ----
+ #include <stdarg.h>
+ #include <dlfcn.h>
+ #include <unistd.h>
+ 
+ #include <audio/audiolib.h>
+ #include <audio/soundlib.h>
+ #include <audio/sound.h>
+ 
+ static NAS_disable_real_esd = 0;
+ 
+ #define	NAS_SOUND_PORT_DURATION (1)
+ 
+ static int NAS_OPEN_MAX = 65536;	/* a default value */
+ 
+ #define NAS_SERVER_MAX  16
+ 
+ /* Manage file descriptor for NAS */
+ 
+ typedef struct
+ {
+     AuFlowID            flow;
+ 
+     /* bucket */
+ 
+     AuBucketID		bucket;
+ 
+     /* buffer : if bucket is == AuNone we write to buffer */
+ 
+     AuUint32            size;
+     AuUint32            pos;
+ 
+     char                *buf;
+ } NAS_StreamInfoRec, *NAS_StreamInfoPtr;
+ 
+ typedef struct NAS_SampleInfoRec
+ {
+     /* links */
+ 
+     struct NAS_SampleInfoRec*	next;
+     struct NAS_SampleInfoRec*	prev;
+ 
+     /* data */
+ 
+     AuFlowID            flow;
+     AuBool		loop;
+     
+     AuBucketID		bucket;
+ 
+ } NAS_SampleInfoRec, *NAS_SampleInfoPtr;
+ 
+ typedef struct
+ {
+     /* server */
+ 
+     AuServer*		aud;
+ 
+     /* stream buffer */
+ 
+     NAS_StreamInfoRec	stream;
+ 
+     /* playing samples */
+ 
+     NAS_SampleInfoPtr	next;
+     NAS_SampleInfoPtr	prev;
+ 
+ } NAS_InfoRec, *NAS_InfoPtr;
+ 
+ static NAS_InfoPtr NAS_ServerFd[NAS_SERVER_MAX];
+ static int NAS_CurrentFd = 0;
+ 
+ /* debug feature */
+ 
+ #ifdef DEBUG_NAS
+ inline static void NAS_debug(char* format, ...)
+ {
+     va_list args;
+     va_start(args, format);
+     vfprintf(stderr, format, args);
+     va_end(args);
+ }
+ #else
+ inline static void NAS_debug(char* format, ...)
+ {
+     return;
+ }
+ #endif
+ 
+ /* system calls wrapper */
+ 
+ typedef int (*proto_write)(int __fd, const void *__buf, size_t __n);
+ typedef int (*proto_close)( int __fd);
+ 
+ static int NAS_sys_write_init(int __fd, const void *__buf, size_t __n);
+ static int NAS_sys_close_init( int __fd);
+ 
+ proto_write sys_write = NAS_sys_write_init;
+ proto_close sys_close = NAS_sys_close_init;
+ 
+ /* catch system calls to drive them into NAS wrapper */
+ 
+ static void NAS_init_symbols(void)
+ {
+     void* handle;
+ 
+ #if defined(RTLD_MEMBER)
+     /* AIX dlopen */
+     handle = dlopen("libc.a(shr.o)", RTLD_NOW|RTLD_MEMBER|RTLD_LOCAL);
+ #else
+     handle = dlopen("libc.so", RTLD_NOW);
+ #endif
+ 
+     if (handle == NULL)
+     {
+ 	fprintf(stderr, "Cannot open libc\n");
+ 	exit(1);
+     }
+ 
+     sys_write = (proto_write)dlsym(handle, "write");
+ 
+     sys_close = (proto_close)dlsym(handle, "close");
+ 
+     dlclose(handle);
+ }
+ 
+ static int NAS_sys_write_init(int __fd, const void *__buf, size_t __n)
+ {
+     NAS_init_symbols();
+ 
+     return sys_write(__fd, __buf, __n);
+ }
+ 
+ static int NAS_sys_close_init( int __fd)
+ {
+     NAS_init_symbols();
+ 
+     return sys_close(__fd);
+ }
+ 
+ ssize_t write (int __fd, const void *__buf, size_t __n)
+ {
+     if (__fd < NAS_OPEN_MAX)
+     {
+ 	return sys_write(__fd, __buf, __n);
+     }
+ 
+     return esd_write (__fd, __buf, __n);
+ }
+ 
+ int close ( int __fd)
+ {
+     if (__fd < NAS_OPEN_MAX)
+     {
+ 	return sys_close(__fd);
+     }
+ 
+     return esd_close(__fd);
+ }
+ 
+ static inline NAS_FdSeekEmptySlot(void)
+ {
+     int fd;
+ 
+     /* compact array */
+ 
+     while ( (NAS_CurrentFd > 0) &&
+ 	    (NAS_ServerFd[NAS_CurrentFd - 1] == NULL) )
+     {
+ 	NAS_CurrentFd--;
+     }
+ 
+     /* seek empty slot */
+ 
+     fd = 0;
+     while (fd < NAS_CurrentFd)
+     {
+         if (NAS_ServerFd[fd] == NULL )
+             return fd;
+         fd++;
+     }
+ 	
+     if (NAS_CurrentFd >= NAS_SERVER_MAX)
+     	return -1;
+ 
+     NAS_CurrentFd++;
+ 
+     return NAS_CurrentFd - 1;
+ }
+ 
+ static inline int NAS_NewFd(NAS_InfoPtr nas_info)
+ {
+     int fd;
+ 
+     if (nas_info == NULL)
+         return -1;
+ 
+     fd = NAS_FdSeekEmptySlot();
+ 
+     if (fd == -1)
+         return -1;
+ 
+     NAS_ServerFd[fd] = nas_info;
+ 
+     return fd;
+ }
+ 
+ static inline int NAS_RemoveFd(int fd)
+ {
+     if ( ( fd < 0) || (fd >= NAS_CurrentFd))
+         return -1;
+ 
+     NAS_ServerFd[fd] = NULL;
+ 
+     return 0;
+ }
+ 
+ static NAS_InfoPtr NAS_GetFd(int fd)
+ {
+     if ( ( fd < 0) || (fd >= NAS_CurrentFd))
+ 	return NULL;
+ 
+     return NAS_ServerFd[fd];
+ }
+ 
+ static void NAS_releaseSample(NAS_SampleInfoPtr sample)
+ {
+     if (sample->prev != NULL)
+         sample->prev->next = sample->next;
+     if (sample->next != NULL)
+         sample->next->prev = sample->prev;
+ 
+     sample->next = NULL;
+     sample->prev = NULL;
+ 
+     free(sample);
+ }
+ 
+ static void NAS_addSample(NAS_SampleInfoPtr head, NAS_SampleInfoPtr sample)
+ {
+     sample->prev = head;
+     sample->next = head->next;
+ 
+     if (sample->next != NULL)
+ 	sample->next->prev = sample;
+     head->next = sample;
+ }
+ 
+ static NAS_SampleInfoPtr NAS_seekSample( NAS_SampleInfoPtr head,
+ 					 AuBucketID sample)
+ {
+     NAS_SampleInfoPtr current = head;
+ 
+     while (current != NULL)
+     {
+         if (current->bucket == sample)
+ 	{
+ 	    break;
+ 	}
+ 	current = current->next;
+     }
+ 
+     return current;
+ }
+ 
+ static void NAS_flush(NAS_InfoPtr nas_info)
+ {
+     AuEvent ev;
+ 
+     AuNextEvent(nas_info->aud, AuTrue, &ev);
+     AuDispatchEvent(nas_info->aud, &ev); 
+ }
+ 
+ static void NAS_sendData(AuServer* aud, NAS_StreamInfoPtr streamInfo,
+ 			 AuUint32 numBytes)
+ {
+     NAS_debug("--> NAS_sendData(aud = 0x%x, streamInfo = 0x%x, numBytes = %d)\n", aud, streamInfo, numBytes);
+ 
+     if (numBytes < (streamInfo->pos))
+     {
+ 	NAS_debug( "    (numBytes %d  < (streamInfo->pos) %d)\n",
+ 		   numBytes, streamInfo->pos);
+ 
+         AuWriteElement(aud, streamInfo->flow, 0,
+ 		       numBytes, streamInfo->buf, AuFalse, NULL);
+ 
+         memmove(streamInfo->buf, streamInfo->buf + numBytes,
+ 		streamInfo->pos - numBytes);
+ 
+         streamInfo->pos = streamInfo->pos - numBytes;
+     }
+     else
+     {
+ 	NAS_debug( "    (numBytes %d >= (streamInfo->pos) %d)\n",
+ 		   numBytes, streamInfo->pos);
+ 
+ 	AuWriteElement( aud, streamInfo->flow, 0,
+ 			streamInfo->pos, streamInfo->buf,
+ 			(numBytes > streamInfo->pos), NULL);
+ 
+         streamInfo->pos = 0;
+     }
+ 
+     NAS_debug("<-- NAS_sendData\n");
+ }
+ 
+ static AuBool NAS_sampleEventHandler(AuServer *aud, 
+ 			       AuEvent *ev, AuEventHandlerRec *handler)
+ {
+     NAS_SampleInfoPtr sampleInfo = (NAS_SampleInfoPtr) handler->data;
+     AuElementNotifyEvent *notify;
+     NAS_debug("--> NAS_sampleEventHandler(aud = 0x%x, ev = 0x%x, handler = 0x%x)\n", aud, ev, handler);
+ 
+     switch (ev->type)
+     {
+ 	case AuEventTypeMonitorNotify:
+ 	    NAS_debug("ev->type == AuEventTypeMonitorNotify\n");
+ 	    break;
+ 
+ 	case AuEventTypeElementNotify:
+ 	    NAS_debug("ev->type == AuEventTypeElementNotify\n");
+ 	    notify = (AuElementNotifyEvent *) ev;
+ 
+ 	    switch(notify->kind)
+ 	    {
+ 		case AuElementNotifyKindHighWater:
+ 		    NAS_debug("    ev->kind == AuElementNotifyKindHighWater\n");
+ 		    break;
+ 
+ 		case AuElementNotifyKindLowWater:
+ 		    NAS_debug("    ev->kind == AuElementNotifyKindLowWater\n");
+ 		    break;
+ 
+ 		case AuElementNotifyKindState:
+ 		    NAS_debug("    ev->kind == AuElementNotifyKindState\n");
+ 		    switch(notify->cur_state)
+ 		    {
+ 			case AuStateStop:
+ 			    NAS_debug("        ev->cur_state == AuStateStop\n");
+ 			    NAS_debug("        sample = 0x%x\n", sampleInfo->bucket);
+ 			    if (notify->reason == AuReasonEOF)
+ 			    {
+ 			       NAS_debug("        notify->reason == AuReasonEOF\n");
+ 				if (sampleInfo->loop)
+ 				{
+ 					break;
+ 				}
+ 			    	AuStopFlow( handler->aud,
+ 					    sampleInfo->flow, NULL);
+ 			    }
+ 			    AuReleaseScratchFlow( handler->aud,
+ 						  sampleInfo->flow, NULL);
+ 			    AuUnregisterEventHandler( handler->aud, handler);
+ 			    NAS_releaseSample(sampleInfo);
+ 			    break;
+ 
+ 			case AuStatePause:
+ 			    NAS_debug("        ev->cur_state == AuStatePause\n");
+ 			    switch(notify->reason)
+ 			    {
+ 				case AuReasonUser:
+ 				    NAS_debug("            ev->reason == AuReasonUser\n");
+ 				    break;
+ 			        case AuReasonUnderrun:
+ 				    NAS_debug("            ev->reason == AuReasonUnderrun\n");
+ 				    break;
+ 			        case AuReasonOverrun:
+ 				    NAS_debug("            ev->reason == AuReasonOverrun\n");
+ 				    break;
+ 			        case AuReasonEOF:
+ 				    NAS_debug("            ev->reason == AuReasonOverrun\n");
+ 				    break;
+ 			        case AuReasonWatermark:
+ 				    NAS_debug("            ev->reason == AuReasonWatermark\n");
+ 				    break;
+ 				case AuReasonHardware:
+ 				    NAS_debug("            ev->reason == AuReasonHardware\n");
+ 				    if (AuSoundRestartHardwarePauses)
+ 				        AuStartFlow( handler->aud,
+ 						     sampleInfo->flow, NULL);
+ 				    else
+ 				        AuStopFlow( handler->aud,
+ 						    sampleInfo->flow, NULL);
+ 				    break;
+ 				default:
+ 				    NAS_debug("            ev->reason == UNKNOWN !\n");
+ 				    break;
+ 			    }
+ 			    break;
+ 		    }
+ 		    break;
+ 	    }
+ 	    break;
+     }
+ 
+     NAS_debug("<-- NAS_sampleEventHandler\n");
+ 
+     return AuTrue;
+ }
+ 
+ static AuBool NAS_streamEventHandler(AuServer *aud, 
+ 			       AuEvent *ev, AuEventHandlerRec *handler)
+ {
+     NAS_StreamInfoPtr streamInfo = (NAS_StreamInfoPtr) handler->data;
+     AuElementNotifyEvent *notify;
+     NAS_debug("--> NAS_streamEventHandler(aud = 0x%x, ev = 0x%x, handler = 0x%x)\n", aud, ev, handler);
+ 
+     switch (ev->type)
+     {
+ 	case AuEventTypeMonitorNotify:
+ 	    NAS_debug("ev->type == AuEventTypeMonitorNotify\n");
+ 	    break;
+ 
+ 	case AuEventTypeElementNotify:
+ 	    NAS_debug("ev->type == AuEventTypeElementNotify\n");
+ 	    notify = (AuElementNotifyEvent *) ev;
+ 
+ 	    switch(notify->kind)
+ 	    {
+ 		case AuElementNotifyKindHighWater:
+ 		    NAS_debug("    ev->kind == AuElementNotifyKindHighWater\n");
+ 		    break;
+ 
+ 		case AuElementNotifyKindLowWater:
+ 		    NAS_debug("    ev->kind == AuElementNotifyKindLowWater\n");
+ 		    NAS_sendData(handler->aud, streamInfo, notify->num_bytes);
+ 		    break;
+ 
+ 		case AuElementNotifyKindState:
+ 		    NAS_debug("    ev->kind == AuElementNotifyKindState\n");
+ 		    switch(notify->cur_state)
+ 		    {
+ 			case AuStateStop:
+ 			    NAS_debug("        ev->cur_state == AuStateStop\n");
+ 			    if (streamInfo->flow != AuNone)
+ 			    {
+ 			    	if (notify->reason == AuReasonEOF)
+ 			    	{
+ 			    		AuStopFlow( handler->aud,
+ 					    	streamInfo->flow, NULL);
+ 			        }
+ 			        AuReleaseScratchFlow( handler->aud,
+ 						      streamInfo->flow, NULL);
+ 			        streamInfo->flow = AuNone;
+ 			    }
+ 			    AuUnregisterEventHandler( handler->aud,
+ 						      handler);
+ 			    break;
+ 
+ 			case AuStatePause:
+ 			    NAS_debug("        ev->cur_state == AuStatePause\n");
+ 			    switch(notify->reason)
+ 			    {
+ 				case AuReasonUser:
+ 				    NAS_debug("            ev->reason == AuReasonUser\n");
+ 				    break;
+ 			        case AuReasonUnderrun:
+ 			        case AuReasonOverrun:
+ 			        case AuReasonEOF:
+ 			        case AuReasonWatermark:
+ 				    NAS_debug("            ev->reason == %d\n", notify->reason);
+ 				    NAS_sendData( handler->aud, streamInfo,
+ 						  notify->num_bytes);
+ 				    break;
+ 				case AuReasonHardware:
+ 				    NAS_debug("            ev->reason == AuReasonHardware\n");
+ 				    if (AuSoundRestartHardwarePauses)
+ 				        AuStartFlow( handler->aud,
+ 						     streamInfo->flow, NULL);
+ 				    else
+ 				        AuStopFlow( handler->aud,
+ 						    streamInfo->flow, NULL);
+ 				    break;
+ 				default:
+ 				    NAS_debug("            ev->reason == UNKNOWN !\n");
+ 				    break;
+ 			    }
+ 			    break;
+ 		    }
+ 		    break;
+ 	    }
+ 	    break;
+     }
+ 
+     NAS_debug("<-- NAS_streamEventHandler\n");
+ 
+     return AuTrue;
+ }
+ 
+ static AuDeviceID NAS_getDevice(AuServer* aud, int numTracks)
+ {
+     int i;
+ 
+     for (i = 0; i < AuServerNumDevices(aud); i++)
+     {
+        if ( (AuDeviceKind(AuServerDevice(aud, i))
+ 					== AuComponentKindPhysicalOutput) &&
+ 	    (AuDeviceNumTracks(AuServerDevice(aud, i)) == numTracks ))
+ 	{
+ 	    return AuDeviceIdentifier(AuServerDevice(aud, i));
+ 	}
+     }
+ 
+     return AuNone;
+ }
+ 
+ static int NAS_allocBuffer(NAS_InfoPtr nas_info)
+ {
+     if (nas_info->stream.buf != NULL)
+     {
+ 	free(nas_info->stream.buf);
+     }
+ 
+     nas_info->stream.buf = (char *) malloc(nas_info->stream.size);
+     if (nas_info->stream.buf == NULL)
+     {
+ 	return -1;
+     }
+ 
+     nas_info->stream.pos = 0;
+ 
+     return 0;
+ }
+ 
+ static int NAS_createFlow(NAS_InfoPtr nas_info,
+ 			  unsigned char format,
+ 			  unsigned short rate,
+ 			  int numTracks)
+ {
+     AuDeviceID device;
+     AuElement elements[2];
+     AuUint32 buf_samples;
+ 
+     device = NAS_getDevice(nas_info->aud, numTracks);
+     if (device == AuNone)
+     {
+ 	return -1;
+     } 
+     nas_info->stream.bucket = AuNone;
+ 
+     nas_info->stream.flow = AuGetScratchFlow(nas_info->aud, NULL);
+     if (nas_info->stream.flow == 0)
+     {
+ 	return -1;
+     }
+ 
+     buf_samples = rate * NAS_SOUND_PORT_DURATION;
+ 
+     AuMakeElementImportClient( &elements[0],		/* element */
+ 			       rate,			/* rate */
+ 			       format,			/* format */
+ 			       numTracks,		/* number of tracks */
+ 			       AuTrue,			/* discart */
+ 			       buf_samples,		/* max samples */
+ 			       (AuUint32) (buf_samples / 100
+ 					* AuSoundPortLowWaterMark),
+ 							/* low water mark */
+ 			       0,			/* num actions */
+ 			       NULL);
+ 
+     AuMakeElementExportDevice( &elements[1],		/* element */
+ 			       0,			/* input */
+ 			       device,			/* device */
+ 			       rate,			/* rate */
+ 			       AuUnlimitedSamples,	/* num samples */
+ 			       0,			/* num actions */
+ 			       NULL);			/* actions */
+  
+     AuSetElements( nas_info->aud,			/* server */
+ 		   nas_info->stream.flow,		/* flow ID */
+ 		   AuTrue,				/* clocked */
+ 		   2,					/* num elements */
+ 		   elements,				/* elements */
+ 		   NULL);
+ 
+     AuRegisterEventHandler( nas_info->aud,		/* server */
+ 			    AuEventHandlerIDMask,	/* value mask */
+ 			    0,				/* type */
+ 			    nas_info->stream.flow,	/* flow ID */
+ 			    NAS_streamEventHandler,	/* callback */
+ 			    (AuPointer)&nas_info->stream);	/* data */
+ 
+     nas_info->stream.size = buf_samples * numTracks*AuSizeofFormat(format);
+     if (NAS_allocBuffer(nas_info) < 0)
+     {
+ 	AuReleaseScratchFlow(nas_info->aud, nas_info->stream.flow, NULL);
+ 
+ 	return -1;
+     }
+ 
+     AuStartFlow(nas_info->aud, nas_info->stream.flow, NULL);
+ 
+     return 0;
+ }
+ 
+ int NAS_write(NAS_InfoPtr nas_info, unsigned char* buf, int len)
+ {
+     int pos = 0;
+     int remaining;
+     int available;
+ 
+     NAS_debug("--> NAS_write\n");
+ 
+     /* if this stream is to bucket, don't bufferize */
+ 
+     if (nas_info->stream.bucket != AuNone)
+     {
+ 	AuWriteElement( nas_info->aud, nas_info->stream.flow, 
+ 			0, len, buf, AuFalse, NULL);
+ 	NAS_debug("<-- NAS_write\n");
+ 
+ 	return len;
+     }
+ 
+     /* stream is a playing sound, use buffer */
+ 
+     if (nas_info->stream.buf == NULL)
+     {
+ 	return -1;
+     }
+    
+     remaining = len;
+     while ( remaining > 0)
+     {
+ 	/* number of bytes we can copy to buffer */
+ 
+ 	available = remaining > nas_info->stream.size - nas_info->stream.pos ?
+ 		    nas_info->stream.size - nas_info->stream.pos :
+ 		    remaining;
+ 
+ 	/* fill the buffer */
+ 
+         memcpy( nas_info->stream.buf + nas_info->stream.pos,
+                 buf + pos, available);
+ 
+         nas_info->stream.pos += available;
+         pos += available;
+ 
+ 	remaining -= available;
+ 
+ 	/* if we have more bytes, need to flush the buffer */
+ 
+ 	if (remaining > 0)
+ 	{
+ 	    while (nas_info->stream.pos == nas_info->stream.size)
+ 	    {
+ 		NAS_flush(nas_info);
+ 	    }
+ 	}
+     }
+ 
+     /* give some time to event handler */
+ 
+     AuSync(nas_info->aud, AuFalse);
+ 
+     NAS_debug("<-- NAS_write\n");
+ 
+     return len;
+ }
+ 
+ void NAS_get_esd_format(esd_format_t esd_format, 
+ 			unsigned char* format, int* numTracks)
+ {
+     if ( (esd_format & ESD_MASK_BITS) == ESD_BITS8 )
+         *format = AuFormatLinearUnsigned8;
+     else
+ #ifdef WORDS_BIGENDIAN
+         *format = AuFormatLinearSigned16MSB;
+ #else
+         *format = AuFormatLinearSigned16LSB;
+ #endif
+ 
+     if ( (esd_format & ESD_MASK_CHAN) == ESD_MONO)
+         *numTracks = 1;
+     else
+         *numTracks = 2;
+ }
+ 
+ int esd_open_sound( const char *host )
+ {
+     NAS_InfoPtr nas_info;
+     char* error;
+     int fd;
+     NAS_debug("--> esd_open_sound\n");
+ 
+     if (!NAS_disable_real_esd && (getenv("AUDIOSERVER") == NULL))
+     {
+ 	/* try to use real ESD server */
+ 
+ 	fd = NAS_esd_open_sound(host);
+ 	if ( fd >= 0 )
+ 	{
+ 	    NAS_debug("    USING ESD SERVER\n");
+ 	    return fd;
+ 	}
+     }
+     NAS_disable_real_esd = 1;
+ 
+     /* try to use NAS server */
+ 
+     if ( !host ) host = getenv("ESPEAKER");
+ 
+     NAS_OPEN_MAX = sysconf(_SC_OPEN_MAX);
+     nas_info = (NAS_InfoPtr)malloc(sizeof(NAS_InfoRec));
+     if (nas_info == NULL)
+     {
+ 	NAS_debug("<-- esd_open_sound (nas_info == NULL)\n");
+         return -1;
+     }
+ 
+     nas_info->aud = AuOpenServer( host, 0, NULL, 0, NULL, &error);
+     if (nas_info->aud == NULL)
+     {
+         free(nas_info);
+ 	AuFree(error);
+ 
+ 	NAS_debug("<-- esd_open_sound (nas_info->aud == NULL)\n");
+ 
+         return -1;
+     }
+ 
+     nas_info->stream.flow = AuNone;
+     nas_info->stream.size = 0;
+     nas_info->stream.pos = 0;
+     nas_info->stream.buf = NULL;
+     nas_info->stream.bucket = AuNone;
+ 
+     nas_info->next = NULL;
+     nas_info->prev = NULL;
+ 
+     fd = NAS_NewFd(nas_info);
+     if (fd == -1)
+     {
+         AuCloseServer(nas_info->aud);
+ 	free(nas_info);
+ 
+ 	NAS_debug("<-- esd_open_sound (fd == -1)\n");
+ 
+         return -1;
+     }
+ 
+     NAS_debug("<-- esd_open_sound\n");
+ 
+     return NAS_OPEN_MAX + fd;
+ }
+ 
+ int esd_close( int esd )
+ {
+     NAS_InfoPtr nas_info;
+ 
+     NAS_debug("--> esd_close\n");
+ 
+     nas_info = NAS_GetFd(esd - NAS_OPEN_MAX);
+ 
+     if (nas_info == NULL)
+         return -1;
+ 
+     NAS_RemoveFd(esd - NAS_OPEN_MAX);
+ 
+     if (nas_info->aud != NULL)
+     {
+ 	while ( nas_info->next || 
+ 		(nas_info->stream.pos && nas_info->stream.buf))
+ 	{
+ 	    NAS_flush(nas_info);
+ 	}
+ 	if (nas_info->stream.buf != NULL)
+ 	{
+ 	    free(nas_info->stream.buf);
+ 	    nas_info->stream.buf = NULL;
+ 	}
+         AuCloseServer(nas_info->aud);
+     }
+ 
+     while(nas_info->next != NULL)
+     {
+         NAS_releaseSample(nas_info->next);
+     }
+     free(nas_info);
+ 
+     NAS_debug("<-- esd_close\n");
+ 
+     return 0;
+ }
+ 
+ int esd_play_stream( esd_format_t esd_format, int rate,
+ 		     const char *host, const char *name )
+ {
+     int sock;
+     int ret;
+     unsigned char format;
+     int numtracks;
+     NAS_InfoPtr nas_info;
+ 
+     NAS_debug("--> esd_play_stream(esd_format = 0x%x, rate = %d, host = %s, name = %s)\n", esd_format, rate, host, name);
+ 
+     if (!NAS_disable_real_esd && (getenv("AUDIOSERVER") == NULL))
+     {
+ 	/* try to use real ESD server */
+ 
+ 	sock = NAS_esd_play_stream(esd_format, rate, host, name);
+ 	if (sock >= 0)
+ 	{
+ 	    NAS_debug("    USING ESD SERVER\n");
+ 	    return sock;
+ 	}
+     } 
+     NAS_disable_real_esd = 1;
+ 
+     /* try to use NAS server */
+ 
+     sock = esd_open_sound(host);
+     if (sock < 0)
+     {
+ 	NAS_debug("<-- esd_play_stream() (sock < 0)\n");
+ 	return -1;
+     }
+ 
+     if ( !host ) host = getenv("ESPEAKER");
+     nas_info = NAS_GetFd(sock - NAS_OPEN_MAX);
+ 
+     NAS_get_esd_format(esd_format, &format, &numtracks);
+ 
+     ret = NAS_createFlow( nas_info, format, rate, numtracks);
+ 
+     if (ret < 0)
+     {
+ 	esd_close(sock - NAS_OPEN_MAX);
+ 
+ 	NAS_debug("<-- esd_play_stream() (NAS_createFlow() < 0)\n");
+ 	return -1;
+     }
+ 
+     NAS_debug("<-- esd_play_stream\n");
+ 
+     return sock;
+ }
+ 
+ int esd_play_stream_fallback( esd_format_t format, int rate,
+ 			      const char *host, const char *name )
+ {
+     int sock;
+ 
+     NAS_debug("--> esd_play_stream_fallback\n");
+ 
+     if (!NAS_disable_real_esd && (getenv("AUDIOSERVER") == NULL))
+     {
+     	/* try to use real ESD server */
+ 
+     	sock = NAS_esd_play_stream_fallback(format, rate, host, name);
+     	if (sock >= 0)
+     	{
+ 	    NAS_debug("    USING ESD SERVER\n");
+ 	    return sock;
+     	}
+     } 
+     NAS_disable_real_esd = 1;
+     
+     /* try to use NAS server */
+ 
+     return esd_play_stream(format, rate, host, name);
+ }
+ 
+ int esd_sample_cache( int esd, esd_format_t esd_format, const int rate,
+                       const int size, const char *name )
+ {
+     unsigned char format;
+     int numTracks;
+     NAS_InfoPtr nas_info;
+     AuUint32 numSamples;
+     AuString desc;
+     int import;
+ 
+     NAS_debug("--> esd_sample_cache(esd = %d, esd_format = 0x%x, rate = %d, size = %d, name = %s)\n", esd, esd_format, rate, size, name);
+ 
+     if (esd < NAS_OPEN_MAX)
+     {
+ 	return NAS_esd_sample_cache(esd, esd_format, rate, size, name);
+     }
+ 
+     nas_info = NAS_GetFd(esd - NAS_OPEN_MAX);
+ 
+     if (nas_info == NULL)
+         return -1;
+ 
+     if (nas_info->stream.buf != NULL)
+     {
+ 	return -1;
+     }
+ 
+     NAS_get_esd_format(esd_format, &format, &numTracks);
+ 
+     numSamples = size / (numTracks * AuSizeofFormat(format));
+ 
+     NAS_debug("    numSamples = %d\n", numSamples);
+ 
+     desc.type = AuStringLatin1;
+     desc.len = strlen(name);
+     desc.data = (char*)name;
+ 
+     nas_info->stream.bucket = AuCreateBucket( nas_info->aud,
+ 				       format,
+ 				       numTracks,
+ 				       AuAccessAllMasks,
+ 				       rate,
+ 				       numSamples,
+ 				       &desc,
+ 				       NULL);
+     if (nas_info->stream.bucket == AuNone)
+     {
+ 	return -1;
+     }
+ 
+     nas_info->stream.flow = AuGetScratchFlowToBucket( nas_info->aud,
+ 					       nas_info->stream.bucket,
+ 					       &import,
+ 					       NULL);
+     if (nas_info->stream.flow == AuNone)
+     {
+ 	AuReleaseScratchFlow(nas_info->aud, nas_info->stream.flow, NULL);
+ 	return -1;
+     }
+ 
+     NAS_debug("<-- esd_sample_cache() = 0x%x\n", nas_info->stream.bucket);
+ 
+     return nas_info->stream.bucket;
+ }
+ 
+ int esd_confirm_sample_cache( int esd )
+ {
+     NAS_InfoPtr nas_info;
+     AuBucketID bucket;
+ 
+     NAS_debug("--> esd_confirm_sample_cache(esd = %d)\n", esd);
+ 
+     if (esd < NAS_OPEN_MAX)
+     {
+ 	return NAS_esd_confirm_sample_cache(esd);
+     }
+ 
+     nas_info = NAS_GetFd(esd - NAS_OPEN_MAX);
+ 
+     if (nas_info == NULL)
+         return -1;
+ 
+     AuReleaseScratchFlow(nas_info->aud, nas_info->stream.flow, NULL);
+     
+     bucket = nas_info->stream.bucket;
+     nas_info->stream.bucket = AuNone;
+     nas_info->stream.flow = AuNone;
+ 
+     NAS_debug("<-- esd_confirm_sample_cache\n");
+ 
+     return bucket;
+ }
+ 
+ int esd_sample_getid( int esd, const char *name)
+ {
+     NAS_InfoPtr nas_info;
+     AuBucketAttributes *list;
+     AuBucketAttributes attr;
+     int numBuckets;
+     AuBucketID bucket;
+ 
+     NAS_debug("--> esd_sample_getid(esd = %d, name = %s)\n", esd, name);
+ 
+     if (esd < NAS_OPEN_MAX)
+     {
+ 	return NAS_esd_sample_getid(esd, name);
+     }
+ 
+     nas_info = NAS_GetFd(esd - NAS_OPEN_MAX);
+ 
+     if (nas_info == NULL)
+         return -1;
+ 
+     AuSetString( AuBucketDescription(&attr),
+ 		 AuStringLatin1, strlen(name), (char*)name);
+ 
+     list = AuListBuckets ( nas_info->aud, AuCompCommonDescriptionMask,
+ 			   &attr, &numBuckets, NULL);
+ 
+     if (list == NULL)
+     {
+ 	NAS_debug("<-- esd_sample_getid() = 0x%x\n", -1);
+ 
+ 	return -1;
+     }
+ 
+     bucket = AuBucketIdentifier(list);
+ 
+     AuFreeBucketAttributes(nas_info->aud, numBuckets, list);
+ 
+     NAS_debug("<-- esd_sample_getid() = 0x%x\n", bucket);
+ 
+     return bucket;
+ }
+ 
+ int esd_sample_play( int esd, int sample )
+ {
+     NAS_InfoPtr nas_info;
+     NAS_SampleInfoPtr current;
+     AuDeviceID device;
+     AuElement elements[2];
+     AuBucketAttributes *ba;
+     AuEvent ev;
+ 
+     NAS_debug("--> esd_sample_play(esd = %d, sample = 0x%x)\n", esd, sample);
+ 
+     if (esd < NAS_OPEN_MAX)
+     {
+ 	return NAS_esd_sample_play(esd, sample);
+     }
+ 
+     nas_info = NAS_GetFd(esd - NAS_OPEN_MAX);
+ 
+     if (nas_info == NULL)
+         return -1;
+ 
+     ba = AuGetBucketAttributes(nas_info->aud, sample, NULL);
+     if (ba == AuNone)
+     {
+ 	return -1;
+     }
+ 
+     device = NAS_getDevice(nas_info->aud, AuBucketNumTracks(ba));
+     if (device == AuNone)
+     {
+ 	AuFreeBucketAttributes(nas_info->aud, 1, ba);
+         return -1;
+     }
+ 
+     current = (NAS_SampleInfoPtr)malloc(sizeof(NAS_SampleInfoRec));
+     if (current == NULL)
+     {
+ 	AuFreeBucketAttributes(nas_info->aud, 1, ba);
+         return -1;
+     }
+ 
+     NAS_addSample((NAS_SampleInfoPtr)&(nas_info->next), current);
+ 
+     current->loop = AuFalse;
+     current->bucket = sample;
+ 
+     current->flow = AuGetScratchFlow(nas_info->aud, NULL);
+     if (current->flow == AuNone)
+     {
+ 	AuFreeBucketAttributes( nas_info->aud, 1, ba);
+ 	return -1;
+     }
+ 
+     AuMakeElementImportBucket( &elements[0], AuBucketSampleRate(ba),
+ 			       sample, AuUnlimitedSamples, 
+ 			       0, 0, NULL);
+     AuMakeElementExportDevice(&elements[1], 0, device, AuBucketSampleRate(ba),
+ 			      AuUnlimitedSamples, 0, NULL);
+ 
+     AuSetElements(nas_info->aud, current->flow, AuTrue, 2, elements, NULL);
+ 
+     AuFreeBucketAttributes(nas_info->aud, 1, ba);
+ 
+     AuRegisterEventHandler( nas_info->aud, AuEventHandlerIDMask,
+                             0, current->flow, NAS_sampleEventHandler,
+                             (AuPointer) current );
+ 
+     AuStartFlow(nas_info->aud, current->flow, NULL);
+ 
+     AuSync(nas_info->aud, AuFalse);
+ 
+     NAS_debug("<-- esd_sample_play\n");
+ 
+     return 0;
+ }
+ 
+ int esd_sample_free( int esd, int sample )
+ {
+     NAS_InfoPtr nas_info;
+     NAS_SampleInfoPtr sampleInfo;
+     NAS_SampleInfoPtr prev;
+ 
+     NAS_debug("--> esd_sample_free(esd = 0x%x, sample = 0x%x)\n", esd, sample);
+ 
+     if (esd < NAS_OPEN_MAX)
+     {
+ 	return NAS_esd_sample_free(esd, sample);
+     }
+ 
+     nas_info = NAS_GetFd(esd - NAS_OPEN_MAX);
+ 
+     if (nas_info == NULL)
+         return -1;
+ 
+     /* is this sample playing ? So wait */
+ 
+     sampleInfo = NAS_seekSample(nas_info->next, sample);
+     if (sampleInfo)
+     {
+ 	prev = sampleInfo->prev;
+ 	while (prev == sampleInfo->prev)
+ 	{
+ 		NAS_flush(nas_info);
+ 	}
+     }
+ 
+     AuDestroyBucket(nas_info->aud, sample, NULL);
+     AuSync(nas_info->aud, AuFalse);
+ 
+     NAS_debug("<-- esd_sample_free\n");
+ 
+     return sample;
+ }
+ 
+ int esd_sample_loop( int esd, int sample )
+ {
+     NAS_InfoPtr nas_info;
+     AuDeviceID device;
+     AuElement elements[2];
+     AuElementAction actions[4];
+     AuBucketAttributes *ba;
+     AuEvent ev;
+     NAS_SampleInfoPtr current;
+ 
+     NAS_debug("--> esd_sample_loop(esd = %d, sample = 0x%x)\n", esd, sample);
+ 
+     if (esd < NAS_OPEN_MAX)
+     {
+ 	return NAS_esd_sample_play(esd, sample);
+     }
+ 
+     nas_info = NAS_GetFd(esd - NAS_OPEN_MAX);
+ 
+     if (nas_info == NULL)
+         return -1;
+ 
+     ba = AuGetBucketAttributes(nas_info->aud, sample, NULL);
+     if (ba == AuNone)
+     {
+ 	return -1;
+     }
+ 
+     device = NAS_getDevice(nas_info->aud, AuBucketNumTracks(ba));
+     if (device == AuNone)
+     {
+         return -1;
+     }
+ 
+     current = (NAS_SampleInfoPtr)malloc(sizeof(NAS_SampleInfoRec));
+     if (current == NULL)
+     {
+ 	AuFreeBucketAttributes(nas_info->aud, 1, ba);
+ 	return -1;
+     }
+ 
+     current->loop = AuTrue;
+     current->bucket = sample;
+ 
+     NAS_addSample((NAS_SampleInfoPtr)&(nas_info->next), current);
+ 
+     current->flow = AuGetScratchFlow(nas_info->aud, NULL);
+     if (current->flow == AuNone)
+     {
+ 	AuFreeBucketAttributes( nas_info->aud, 1, ba);
+ 	return -1;
+     }
+ 
+     /* to loop sound */
+ 
+     AuMakeSendNotifyAction( &actions[0], 
+ 			    AuStatePause, AuStateAny, AuReasonAny);
+     AuMakeSendNotifyAction( &actions[1],
+ 			    AuStateStop, AuStateAny, AuReasonAny);
+     AuMakeChangeStateAction( &actions[2],
+ 			     AuStateStop, AuStateAny, AuReasonUser,
+ 			     current->flow, AuElementAll, AuStateStop);
+     AuMakeChangeStateAction( &actions[3],
+ 			     AuStateStop, AuStateAny, AuReasonEOF, 
+ 			     current->flow, 0, AuStateStart);
+ 
+     /* create bucket */
+ 
+     AuMakeElementImportBucket( &elements[0], AuBucketSampleRate(ba),
+ 			       sample, AuUnlimitedSamples, 
+ 			       0, 4, actions);
+     AuMakeElementExportDevice(&elements[1], 0, device, AuBucketSampleRate(ba),
+ 			      AuUnlimitedSamples, 0, NULL);
+ 
+     AuSetElements(nas_info->aud, current->flow, AuTrue, 2, elements, NULL);
+ 
+     AuFreeBucketAttributes(nas_info->aud, 1, ba);
+ 
+     AuRegisterEventHandler( nas_info->aud, AuEventHandlerIDMask,
+                             0, current->flow, NAS_sampleEventHandler,
+                             (AuPointer) current );
+ 
+     AuStartFlow(nas_info->aud, current->flow, NULL);
+ 
+     AuSync(nas_info->aud, AuFalse);
+ 
+     NAS_debug("<-- esd_sample_loop\n");
+ 
+     return 0;
+ }
+ 
+ int esd_sample_stop( int esd, int sample )
+ {
+     NAS_InfoPtr nas_info;
+     NAS_SampleInfoPtr sampleInfo;
+ 
+     NAS_debug("--> esd_sample_stop( esd = %d, sample = 0x%x)\n" ,esd, sample);
+ 
+     if (esd < NAS_OPEN_MAX)
+     {
+ 	return NAS_esd_sample_stop(esd, sample);
+     }
+ 
+     nas_info = NAS_GetFd(esd - NAS_OPEN_MAX);
+ 
+     sampleInfo = NAS_seekSample(nas_info->next, sample);
+ 
+     if (sampleInfo != NULL)
+     {
+ 	sampleInfo->loop = AuFalse;
+ 	AuStopFlow( nas_info->aud, sampleInfo->flow, NULL);
+         AuSync(nas_info->aud, AuFalse);
+     }
+ 
+     NAS_debug("<-- esd_sample_stop()\n");
+ }
+ 
+ ssize_t esd_write (int __fd, const void *__buf, size_t __n)
+ {
+     NAS_InfoPtr nas_info;
+     ssize_t ret;
+ 
+     nas_info = NAS_GetFd(__fd - NAS_OPEN_MAX);
+ 
+     ret = NAS_write( nas_info, (unsigned char*)__buf, __n);
+ 
+     return ret;
+ }
+ 
+ int esd_get_latency(int esd)
+ {
+     NAS_debug("--> esd_get_latency()\n");
+ 
+     if (esd < NAS_OPEN_MAX)
+     {
+ 	NAS_debug("NAS_esd_get_latency <-- esd_get_latency\n");
+ 
+ 	return NAS_esd_get_latency(esd);
+     }
+ 
+     NAS_debug("<-- esd_get_latency()\n");
+ 
+     return 44100 * 2 * NAS_SOUND_PORT_DURATION;
+ }
+ 
+ /* This part is from esdmgr.c */
+ 
+ extern esd_server_info_t *NAS_esd_get_server_info( int esd );
+ 
+ esd_server_info_t *esd_get_server_info( int esd )
+ {
+     NAS_InfoPtr nas_info;
+     esd_server_info_t *info;
+     int i;
+ 
+     NAS_debug("--> esd_get_server_info()\n");
+ 
+     if (esd < NAS_OPEN_MAX)
+     {
+ 	return NAS_esd_get_server_info(esd);
+     }
+ 
+     nas_info = NAS_GetFd(esd - NAS_OPEN_MAX);
+ 
+     info = (esd_server_info_t *)malloc(sizeof(esd_server_info_t));
+     if (info == NULL)
+     {
+ 	return info;
+     }
+ 
+     info->version = 0;
+     info->rate = AuServerMaxSampleRate(nas_info->aud);
+ 
+     info->format = 0;
+     for (i = 0; i < AuServerNumFormats(nas_info->aud); i++)
+     {
+ 	switch(AuServerFormat(nas_info->aud, i))
+ 	{
+ 	    case AuFormatLinearUnsigned8:
+ 		info->format |= ESD_BITS8;
+ 		break;
+ 
+ 	    case AuFormatLinearSigned16LSB:
+ 		info->format |= ESD_BITS16;
+ 		break;
+ 	}
+     }
+ 
+     for (i = 0; i < AuServerNumDevices(nas_info->aud); i++)
+     {
+        if (AuDeviceKind(AuServerDevice(nas_info->aud, i))
+ 					== AuComponentKindPhysicalOutput)
+ 	{
+ 	    if (AuDeviceNumTracks(AuServerDevice(nas_info->aud, i)) == 1)
+ 	    {
+ 		info->format |= ESD_MONO;
+ 	    }
+ 	    else if (AuDeviceNumTracks(AuServerDevice(nas_info->aud, i)) > 1)
+ 	    {
+ 		info->format |= ESD_STEREO;
+ 	    }
+ 	}
+     }
+ 
+     return info;
+ }
+ 
+ extern esd_info_t *NAS_esd_get_all_info( int esd );
+ 
+ esd_info_t *esd_get_all_info( int esd )
+ {
+     NAS_InfoPtr nas_info;
+     esd_info_t *allinfo;
+ 
+     NAS_debug("--> esd_get_all_info()\n");
+ 
+     if (esd < NAS_OPEN_MAX)
+     {
+ 	return NAS_esd_get_all_info(esd);
+     }
+ 
+     nas_info = NAS_GetFd(esd - NAS_OPEN_MAX);
+ 
+     allinfo = (esd_info_t *)malloc(sizeof(esd_info_t));
+     if (allinfo == NULL)
+     {
+ 	return NULL;
+     }
+ 
+     allinfo->server = esd_get_server_info(esd);
+     allinfo->player_list = NULL;
+     allinfo->sample_list = NULL;
+ 
+     return allinfo;
+ }
+ 
+ int esd_set_stream_pan( int esd, int stream_id,
+ 			int left_scale, int right_scale )
+ {
+     if (esd < NAS_OPEN_MAX)
+     {
+ 	return NAS_esd_set_stream_pan(esd, stream_id, left_scale, right_scale);
+     }
+ 
+     return 0;
+ }
+ 
+ extern int NAS_esd_set_default_sample_pan( int esd, int sample_id,
+ 				int left_scale, int right_scale );
+ int esd_set_default_sample_pan( int esd, int sample_id,
+ 				int left_scale, int right_scale )
+ {
+     if (esd < NAS_OPEN_MAX)
+     {
+ 	return NAS_esd_set_default_sample_pan( esd, sample_id,
+ 					       left_scale, right_scale);
+     }
+ 
+     return 0;
+ }
+ 
+ esd_standby_mode_t esd_get_standby_mode( int esd )
+ {
+     if (esd < NAS_OPEN_MAX)
+     {
+ 	return NAS_esd_get_standby_mode(esd);
+     }
+ 
+     return ESM_RUNNING;
+ }
+ 
+ /* rename real ESD calls */
+ 
+ #define esd_open_sound			NAS_esd_open_sound
+ #define esd_close			NAS_esd_close
+ #define esd_get_latency			NAS_esd_get_latency
+ #define esd_sample_cache		NAS_esd_sample_cache
+ #define esd_confirm_sample_cache	NAS_esd_confirm_sample_cache
+ #define esd_sample_getid		NAS_esd_sample_getid
+ #define esd_sample_play			NAS_esd_sample_play
+ #define esd_sample_free			NAS_esd_sample_free
+ #define esd_play_stream			NAS_esd_play_stream
+ #define esd_play_stream_fallback	NAS_esd_play_stream_fallback
+ #define esd_sample_loop			NAS_esd_sample_loop
+ #define esd_sample_stop			NAS_esd_sample_stop
+ #define esd_write			NAS_esd_write
diff -crN ./esound/esdmgr.c /users5/vivierl/sandboxes/gnome_202/src/./esound/esdmgr.c
*** ./esound/esdmgr.c	1999-06-09 00:18:11.000000000 +0200
--- /users5/vivierl/sandboxes/gnome_202/src/./esound/esdmgr.c	2003-02-13 14:14:03.000000000 +0100
***************
*** 1,9 ****
! 
  #include <esd.h>
  #include <stdlib.h>
  #include <stdio.h>
  #include <unistd.h>
  
  /*********************************************************************/
  /* print server into to stdout */
  void esd_print_server_info( esd_server_info_t *server_info )
--- 1,17 ----
! #include "config.h"
  #include <esd.h>
  #include <stdlib.h>
  #include <stdio.h>
  #include <unistd.h>
  
+ #ifdef DRIVER_NAS
+ #define esd_get_server_info NAS_esd_get_server_info
+ #define esd_get_all_info NAS_esd_get_all_info
+ #define esd_set_stream_pan NAS_esd_set_stream_pan
+ #define esd_set_default_sample_pan NAS_esd_set_default_sample_pan
+ #define esd_get_standby_mode NAS_esd_get_standby_mode
+ #endif /* DRIVER_NAS */
+ 
  /*********************************************************************/
  /* print server into to stdout */
  void esd_print_server_info( esd_server_info_t *server_info )
